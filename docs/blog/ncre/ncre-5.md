# 软件开发方法 <!-- {docsify-ignore-all} -->



- 软件开发方法
  - 分类
    - 按照开发风范
      - 自顶向下
      - 自底向上
    - 按照性质
      - 形式化开发
      - 非形式化开发
        - 结构化方法
          - 开发目标清晰
          - 开发工作阶段化
          - 开发文档规范化
          - 设计方法结构化
        - 面向对象方法
          - 面向对象分析
          - 面相对象设计
          - 面向对象程序设计
        - 原型方法
          - 按照实现功能划分
            - 水平原型（行为原型细化需求未实现功能）
            - 垂直原型（结构化原型，实现了部分功能）
          - 按照最终结果划分
            - 抛弃式（探索式原型，解决不确定性，二义性，不完整性，含糊性）
            - 演化式（逐步演化成最终系统，适用于web项目）
        - 构件化方法
          - 构件的获取
            - 从现有构件获取
            - 提取遗留工程的可复用构件
            - 从市场购买商业构件
            - 开发新的符合要求的构件
          - 构件的分类
            - 关键字分类法
            - 刻面分类法
            - 超文本方法
          - 构件复用方法
            - 检索与提取构件
            - 理解与评价构件
            - 修改构件
            - 构件组装
        - 面向服务的方法
        - 敏捷开发方法（以人为核心、迭代）
          - 适应性
          - 面向人的
          - 迭代增量式的开发过程
          - 四个核心价值
            - 沟通
            - 简单
            - 反馈
            - 勇气
          - 12条过程时间规则
            - 计划游戏
            - 小型发布
            - 隐喻
            - 简单设计
            - 测试先行
            - 重构
            - 绝对编程
            - 集体代码所有制
            - 持续集成
            - 每周工作40个小时
            - 现场客户
            - 编码标准
          - 敏捷方法分类
            - xp极限编程-高效、低风险、测试先行（先写测试代码，再编写程序）
            - Cockburn水晶方法-不同项目，不同策略
            - SCRUM并列征求法-迭代。30天为一个迭代周期，按照需求优先级实现。
            - FDD功用驱动方法-开发人员分类。分为指挥者、类程序员
            - 开放式源码-虚拟团队，开发成员分布各地
            - ASD自适应方法-预测-协作-学习
    - 按照适用范围
      - 整体性
      - 局部性
  - 净室软件工程
  - 软件重用与逆向工程
    - 在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。软件元素包括需求分析文档、设计过程、设计文档、程序代码、测试用例和领域知识等
    - 软件重用可区别为横向重用和纵向重用
      - 纵向重用：指在一类具有较多公共性的应用领域之间进行软件重用
      - 横向重用：指重用不同应用领域中的软件元素，例如数据结构、分类算法和人机界面构件等
    - 逆向工程
      - 重构
      - 设计恢复
      - 再工程
        - 在逆向工程所获得新的基础上，修改或重构已有的系统，产生系统的一个新版本
      - 正向工程
        - 不仅从现有系统中恢复设计信息，而且使用该信息去改变或重构现有系统，已改善其整体质量
      - 四个抽象层次
        - 实现级别：抽象的语法树、符号表、过程的设计标识
        - 结构级别：反应程序分量之间相互依赖关系信息，如调用图，结构图，程序和数据结构
        - 功能级别：反应程序功能及程序段之间的关系的信息，如数据和控制流模型
        - 领域级别：反应程序分量或程序实体与应用领域概念之间对应关系的信息，如ER模型
  - 开发模型
    - 瀑布模型
      - 缺点
        - 需求难确定，甚至是不现实不可能的
        - 周期长，很长时间才能得到一个初始版本，需求变更成本也很巨大
      - 特点
        - 上一次活动成果作为本活动的输入
        - 将本次活动成果输入给下一个活动
        - 对本次活动成果实施评审，若成功得到确认进入到下一活动否则返回前一项，甚至更前项活动
    - 原型模型
      - 用户对系统模糊不清，无法准确回答目标系统的需求
      - 要有一定的开发工具和环境的支持
      - 经过对原型的若干次修改，应收敛目标范围，否则可能会失败
      - 对大型软件来说，原型可能非常复杂而难以快速形成，如果没有现成的就不应该考虑使用原型
    - 螺旋模型
      - 瀑布模型与原型模型结合，加入了分线分析，适用于庞大、复杂并具有高风险的系统
    - 喷泉模型
    - 基于可重用构件的模型
    - 快速应用开发RAD
      - 让用户主动地参与到系统开发、设计和构造活动中来
      - 将项目开发组织成一系列重点突出的研讨会、研讨会要让项目投资方、用户、系统分析师、设计人员和开发人员一起参与
      - 通过一种迭代的构造方法，加速需求分析和设计阶段
      - 让用户提前看到一个可工作的系统
    - 统一过程RUP/UP
      - RUP将项目管理、业务建模、分析与设计等统一起来，贯穿整个开发过程。
        - 初始阶段
        - 细化阶段
        - 构建阶段
        - 移交阶段
      - RUP强调采用迭代和增量的方式来开发软件，把整个项目开发分为多个迭代过程。每一次迭代包括分析、设计、实现、测试和部署，有好处
        - 在开发早期就可以对关键影响大的风险进行处理
        - 可以提出一个软件体系结构指导开发
        - 可以更好地处理不可避免的需求变更
        - 可以较早的得到一个可运行的系统费，鼓舞开发时期，增强项目成果的自信心
        - 为开发人员提供一个更高效工作的开发过程